<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SmartCookware - Control BLE</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }
        .card {
            background-color: #f9f9f9;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            text-align: center;
            font-size: 16px;
            margin: 5px 2px;
            cursor: pointer;
            border-radius: 5px;
            width: 100%;
        }
        button:disabled {
            background-color: #cccccc;
        }
        .temperature {
            font-size: 36px;
            text-align: center;
            margin: 20px 0;
        }
        .status {
            font-size: 14px;
            color: #555;
            text-align: center;
        }
        .progress-container {
            width: 100%;
            background-color: #ddd;
            border-radius: 5px;
        }
        .progress-bar {
            height: 20px;
            background-color: #4CAF50;
            border-radius: 5px;
            text-align: center;
            color: white;
            line-height: 20px;
        }
        .step-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        .action-required {
            background-color: #f44336;
            color: white;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin: 15px 0;
        }
        .hidden {
            display: none;
        }
        
        .input-group {
            margin: 10px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        
        .button-small {
            width: auto;
            padding: 5px 10px;
            margin: 5px;
            font-size: 14px;
        }
        
        .flex-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .flex-container input {
            flex: 1;
        }
        
        .version-info {
            text-align: center;
            font-size: 12px;
            color: #888;
            margin-bottom: 20px;
            font-style: italic;
        }

        /* Nuevos estilos para el dise√±o simplificado */
        .recipe-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        .recipe-buttons button {
            margin: 0;
            padding: 12px;
            font-size: 14px;
        }

        .single-button {
            grid-column: 1 / -1;
        }

        .preset-button {
            background-color: #2196F3;
        }

        .preset-button:hover {
            background-color: #1976D2;
        }

        .utility-button {
            background-color: #FF9800;
        }

        .utility-button:hover {
            background-color: #F57C00;
        }

        .advanced-toggle {
            background-color: #9C27B0;
            margin-top: 15px;
        }

        .advanced-toggle:hover {
            background-color: #7B1FA2;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
        }

        h2 {
            margin-top: 0;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <h1>SmartCookware</h1>
    <div class="version-info">Versi√≥n 2.7.7 - Build 20241212-011</div>
    
    <div class="card">
        <button id="connectButton">Conectar dispositivo</button>
        <p class="status" id="statusText">Desconectado</p>
        <p class="status" id="batteryText"></p>
    </div>
    
    <div class="card hidden" id="recipeProgressCard">
        <h2>Progreso de receta</h2>
        <div class="step-info">
            <span id="stepInfo">Paso: --/--</span>
            <span id="timeRemaining">--:--</span>
        </div>
        <div class="progress-container">
            <div class="progress-bar" id="progressBar" style="width:0%">0%</div>
        </div>
    </div>
    
    <div class="card hidden" id="temperatureCard">
        <h2>Temperatura</h2>
        <div class="temperature" id="currentTemp">--¬∞C</div>
        <div id="setpointContainer" class="hidden">
            <p>Temperatura objetivo: <span id="tempSetpoint">--¬∞C</span></p>
        </div>
    </div>
    
    <div class="action-required hidden" id="actionRequiredCard">
        <h2>¬°ACCI√ìN REQUERIDA!</h2>
        <p>Por favor, realiza la acci√≥n necesaria y pulsa el bot√≥n cuando hayas terminado.</p>
        <button id="continueButton">CONTINUAR</button>
    </div>

    <!-- Secci√≥n de recetas simplificada -->
    <div class="card hidden" id="recipeCard">
        <h2>Recetas</h2>
        
        <div class="recipe-buttons">
            <button class="preset-button" onclick="setPresetTemp(100)">Hervir</button>
            <button class="preset-button" onclick="setPresetTemp(180)">Fre√≠r</button>
            <button class="preset-button" onclick="startSteakRecipe()">Filete a la Plancha</button>
            <button class="preset-button" onclick="startPastaRecipe()">Pasta Italiana</button>
            <button class="utility-button" onclick="resetRecipe()">Reset Receta</button>
            <button class="utility-button" onclick="nextStep()">Siguiente Paso</button>
        </div>

        <button class="advanced-toggle" onclick="toggleAdvancedMode()">üîß Modo Avanzado</button>
    </div>

    <!-- Controles avanzados (ocultos por defecto) -->
    <div class="card hidden" id="advancedCard">
        <h2>Controles de Receta</h2>
        
        <!-- Control para enviar paso de receta -->
        <div class="input-group">
            <label>Caracter√≠stica BLE: Steps (Configuraci√≥n de Paso):</label>
            <div class="flex-container">
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #666;">Paso:</label>
                    <input type="number" id="stepNumber" placeholder="Paso actual" min="0" max="10" value="1">
                </div>
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #666;">Total Pasos:</label>
                    <input type="number" id="totalStepsInput" placeholder="Total de pasos" min="0" max="10" value="2">
                </div>
            </div>
            <div class="flex-container">
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #666;">Acci√≥n Requerida:</label>
                    <select id="actionRequired">
                        <option value="0">Sin acci√≥n requerida</option>
                        <option value="1">‚ö†Ô∏è Acci√≥n requerida</option>
                    </select>
                </div>
                <div style="flex: 1;">
                    <label style="font-size: 12px; color: #666;">Temperatura Setpoint:</label>
                    <input type="number" id="targetTemp" placeholder="Temp. objetivo (¬∞C)" min="0" max="300" value="180">
                </div>
            </div>
            <button class="button-small" onclick="sendRecipeStepManual()" style="width: 100%; margin-top: 10px;">üì§ Enviar Configuraci√≥n de Paso</button>
        </div>
        
        <!-- Control para enviar progreso de tiempo -->
        <div class="input-group">
            <label>Caracter√≠stica BLE: Progress (Tiempo del Paso):</label>
            <div style="flex: 1; margin-bottom: 10px;">
                <label style="font-size: 12px; color: #666;">Tiempo Total del Paso (seg):</label>
                <input type="number" id="totalTimeInput" placeholder="Duraci√≥n total del paso" min="1" max="7200" value="300">
            </div>
            <div style="display: flex; gap: 10px; font-size: 12px; color: #666; margin-top: 5px;">
                <span>Ejemplo: 300 seg = 5:00 min</span>
                <span>|</span>
                <span>1800 seg = 30:00 min</span>
            </div>
            <div style="font-size: 11px; color: #888; margin-top: 5px; font-style: italic;">
                * Al enviar, se iniciar√° autom√°ticamente desde el tiempo total especificado
            </div>
            <button class="button-small" onclick="sendRecipeProgressManual()" style="width: 100%; margin-top: 10px;">‚è∞ Iniciar Timer del Paso</button>
        </div>

        <!-- Controles de utilidad -->
        <div class="input-group">
            <label>Controles de Utilidad:</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                <button class="utility-button" onclick="resetRecipe()">üîÑ Reset Receta</button>
                <button class="utility-button" onclick="nextStep()">‚è© Siguiente Paso</button>
            </div>
        </div>

        <button class="advanced-toggle" onclick="toggleAdvancedMode()">üîô Volver al Modo Simple</button>
    </div>

    <script>
        // Actualizar informaci√≥n de versi√≥n en la consola
        console.log('SmartCookware Web App - Versi√≥n 2.7.7');
        console.log('Build: 20241212-011');
        console.log('Caracter√≠sticas: Bot√≥n CONTINUAR equivalente a notificaci√≥n BLE');
        
        // UUIDs de los servicios y caracter√≠sticas BLE - usando formato UUID completo
        // Para los servicios est√°ndar, usamos el formato completo
        const BATTERY_SERVICE_UUID = '0000180f-0000-1000-8000-00805f9b34fb';
        const BATTERY_CHARACTERISTIC_UUID = '00002a19-0000-1000-8000-00805f9b34fb';
        
        // Para servicios personalizados, mantenemos el UUID tal como est√°
        const COOKING_SERVICE_UUID = 'abcd1234-5678-9012-3456-7890abcdef12';
        const TEMP_CHARACTERISTIC_UUID = 'abcd1234-0001-9012-3456-7890abcdef12';
        const PROGRESS_CHARACTERISTIC_UUID = 'abcd1234-0002-9012-3456-7890abcdef12';
        const STEPS_CHARACTERISTIC_UUID = 'abcd1234-0003-9012-3456-7890abcdef12';
        const MESSAGE_CHARACTERISTIC_UUID = 'abcd1234-0004-9012-3456-7890abcdef12';
        const CONTINUE_CHARACTERISTIC_UUID = 'abcd1234-0005-9012-3456-7890abcdef12';
        
        // Variables para el contador de tiempo autom√°tico
        let timerInterval = null;
        let currentRemainingTime = 0;
        let currentTotalTime = 0;
        let isTimerActive = false;
        
        // Variables para rastrear el paso actual de la receta
        let currentStep = 0;
        let totalSteps = 0;
        let currentTempTarget = 0;
        
        // Variables globales
        let device = null;
        let batteryCharacteristic = null;
        let tempCharacteristic = null;
        let progressCharacteristic = null;
        let stepsCharacteristic = null;
        let messageCharacteristic = null;
        let continueCharacteristic = null;
        
        // Estado del modo avanzado
        let isAdvancedMode = false;
        
        // Variable para controlar el estado de la receta
        let activeRecipe = null; // null, 'simple', 'complex'
        
        // Elementos del DOM
        const connectButton = document.getElementById('connectButton');
        const statusText = document.getElementById('statusText');
        const batteryText = document.getElementById('batteryText');
        const temperatureCard = document.getElementById('temperatureCard');
        const currentTemp = document.getElementById('currentTemp');
        const setpointContainer = document.getElementById('setpointContainer');
        const tempSetpoint = document.getElementById('tempSetpoint');
        const recipeProgressCard = document.getElementById('recipeProgressCard');
        const stepInfo = document.getElementById('stepInfo');
        const timeRemaining = document.getElementById('timeRemaining');
        const progressBar = document.getElementById('progressBar');
        const actionRequiredCard = document.getElementById('actionRequiredCard');
        const continueButton = document.getElementById('continueButton');
        const recipeCard = document.getElementById('recipeCard');
        const advancedCard = document.getElementById('advancedCard');
        
        // Eventos
        connectButton.addEventListener('click', connectToDevice);
        continueButton.addEventListener('click', sendContinueSignal);
        
        // Verificar si el navegador soporta Web Bluetooth
        if (!navigator.bluetooth) {
            statusText.textContent = 'Web Bluetooth no soportado por este navegador';
            connectButton.disabled = true;
        }
        
        // Funci√≥n para alternar modo avanzado
        function toggleAdvancedMode() {
            isAdvancedMode = !isAdvancedMode;
            
            if (isAdvancedMode) {
                recipeCard.classList.add('hidden');
                advancedCard.classList.remove('hidden');
            } else {
                advancedCard.classList.add('hidden');
                recipeCard.classList.remove('hidden');
            }
        }
        
        // Funci√≥n para deshabilitar/habilitar botones seg√∫n la receta
        function updateRecipeButtons(recipeType) {
            const hervirBtn = document.querySelector('button[onclick="setPresetTemp(100)"]');
            const freirBtn = document.querySelector('button[onclick="setPresetTemp(180)"]');
            const steakBtn = document.querySelector('button[onclick="startSteakRecipe()"]');
            const pastaBtn = document.querySelector('button[onclick="startPastaRecipe()"]');
            const resetBtn = document.querySelector('button[onclick="resetRecipe()"]');
            const nextBtn = document.querySelector('button[onclick="nextStep()"]');
            
            if (recipeType === 'simple') {
                // Para Hervir/Fre√≠r: deshabilitar otras recetas, habilitar solo Reset
                hervirBtn.disabled = true;
                freirBtn.disabled = true;
                steakBtn.disabled = true;
                pastaBtn.disabled = true;
                resetBtn.disabled = false;
                nextBtn.disabled = true;
                
                hervirBtn.style.opacity = '0.5';
                freirBtn.style.opacity = '0.5';
                steakBtn.style.opacity = '0.5';
                pastaBtn.style.opacity = '0.5';
                nextBtn.style.opacity = '0.5';
                resetBtn.style.opacity = '1';
            } else if (recipeType === 'complex') {
                // Para Filete/Pasta: deshabilitar otras recetas, habilitar Reset y Siguiente Paso
                hervirBtn.disabled = true;
                freirBtn.disabled = true;
                steakBtn.disabled = true;
                pastaBtn.disabled = true;
                resetBtn.disabled = false;
                nextBtn.disabled = false;
                
                hervirBtn.style.opacity = '0.5';
                freirBtn.style.opacity = '0.5';
                steakBtn.style.opacity = '0.5';
                pastaBtn.style.opacity = '0.5';
                resetBtn.style.opacity = '1';
                nextBtn.style.opacity = '1';
            } else {
                // Estado normal: todos habilitados
                hervirBtn.disabled = false;
                freirBtn.disabled = false;
                steakBtn.disabled = false;
                pastaBtn.disabled = false;
                resetBtn.disabled = false;
                nextBtn.disabled = false;
                
                hervirBtn.style.opacity = '1';
                freirBtn.style.opacity = '1';
                steakBtn.style.opacity = '1';
                pastaBtn.style.opacity = '1';
                resetBtn.style.opacity = '1';
                nextBtn.style.opacity = '1';
            }
            
            activeRecipe = recipeType;
        }
        
        // Funci√≥n para presets de temperatura simples
        async function setPresetTemp(temperature) {
            if (!device || !device.gatt.connected) {
                alert('Dispositivo no conectado');
                return;
            }
            
            // Detener cualquier timer activo
            stopAutomaticTimer();
            
            // Ocultar elementos no necesarios para modos simples
            actionRequiredCard.classList.add('hidden');
            recipeProgressCard.classList.add('hidden');
            
            // Enviar configuraci√≥n simple: paso 1/1, sin acci√≥n requerida, temperatura preset
            await sendRecipeStep(1, 1, false, temperature);
            
            // Mostrar temperatura objetivo
            tempSetpoint.textContent = `${temperature}¬∞C`;
            setpointContainer.classList.remove('hidden');
            
            let tempName = temperature === 100 ? 'Hervir' : 'Fre√≠r';
            statusText.textContent = `üî• Modo ${tempName} - ${temperature}¬∞C`;
            
            // Deshabilitar otros botones para recetas simples
            updateRecipeButtons('simple');
            
            console.log(`üî• Modo ${tempName} activado - Sin progreso de receta, solo temperatura: ${temperature}¬∞C`);
        }

        async function connectToDevice() {
            try {
                statusText.textContent = 'Buscando dispositivos...';
                console.log('Intentando conectar... (v2.5.0)');
                
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'SmartCookware' }],
                    optionalServices: [
                        '0000180f-0000-1000-8000-00805f9b34fb',
                        'abcd1234-5678-9012-3456-7890abcdef12'
                    ]
                });
                
                statusText.textContent = 'Conectando...';
                
                const server = await device.gatt.connect();
                device.addEventListener('gattserverdisconnected', onDisconnected);
                
                // Obtener servicio de bater√≠a
                const batteryService = await server.getPrimaryService('0000180f-0000-1000-8000-00805f9b34fb');
                batteryCharacteristic = await batteryService.getCharacteristic('00002a19-0000-1000-8000-00805f9b34fb');
                
                await batteryCharacteristic.startNotifications();
                batteryCharacteristic.addEventListener('characteristicvaluechanged', handleBatteryChange);
                
                const batteryValue = await batteryCharacteristic.readValue();
                updateBatteryLevel(batteryValue);
                
                // Obtener servicio de cocina
                const cookingService = await server.getPrimaryService('abcd1234-5678-9012-3456-7890abcdef12');
                
                tempCharacteristic = await cookingService.getCharacteristic('abcd1234-0001-9012-3456-7890abcdef12');
                progressCharacteristic = await cookingService.getCharacteristic('abcd1234-0002-9012-3456-7890abcdef12');
                stepsCharacteristic = await cookingService.getCharacteristic('abcd1234-0003-9012-3456-7890abcdef12');
                messageCharacteristic = await cookingService.getCharacteristic('abcd1234-0004-9012-3456-7890abcdef12');
                continueCharacteristic = await cookingService.getCharacteristic('abcd1234-0005-9012-3456-7890abcdef12');
                
                await tempCharacteristic.startNotifications();
                tempCharacteristic.addEventListener('characteristicvaluechanged', handleTemperatureChange);
                
                await continueCharacteristic.startNotifications();
                continueCharacteristic.addEventListener('characteristicvaluechanged', handleContinueChange);
                
                const tempValue = await tempCharacteristic.readValue();
                updateTemperature(tempValue);
                
                // Actualizar UI
                statusText.textContent = 'Conectado';
                connectButton.textContent = 'Desconectar';
                connectButton.removeEventListener('click', connectToDevice);
                connectButton.addEventListener('click', disconnectDevice);
                
                // Mostrar tarjetas principales
                temperatureCard.classList.remove('hidden');
                recipeCard.classList.remove('hidden');
                
                console.log('Dispositivo conectado - Dise√±o simplificado activo');
                
            } catch (error) {
                console.error('Error al conectar:', error);
                statusText.textContent = 'Error: ' + error.message;
                alert('Error al conectar: ' + error.message);
            }
        }
        
        function disconnectDevice() {
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
        }
        
        function onDisconnected() {
            statusText.textContent = 'Desconectado';
            batteryText.textContent = '';
            connectButton.textContent = 'Conectar dispositivo';
            connectButton.removeEventListener('click', disconnectDevice);
            connectButton.addEventListener('click', connectToDevice);
            
            // Ocultar tarjetas
            temperatureCard.classList.add('hidden');
            recipeProgressCard.classList.add('hidden');
            actionRequiredCard.classList.add('hidden');
            recipeCard.classList.add('hidden');
            advancedCard.classList.add('hidden');
            
            // Resetear variables
            device = null;
            batteryCharacteristic = null;
            tempCharacteristic = null;
            progressCharacteristic = null;
            stepsCharacteristic = null;
            messageCharacteristic = null;
            continueCharacteristic = null;
            isAdvancedMode = false;
            
            // Rehabilitar todos los botones al desconectar
            updateRecipeButtons(null);
            
            stopAutomaticTimer();
        }
        
        function handleBatteryChange(event) {
            try {
                updateBatteryLevel(event.target.value);
            } catch (error) {
                console.error('Error al procesar cambio de bater√≠a:', error);
            }
        }
        
        function handleTemperatureChange(event) {
            try {
                updateTemperature(event.target.value);
            } catch (error) {
                console.error('Error al procesar cambio de temperatura:', error);
            }
        }
        
        // Funci√≥n original que maneja la notificaci√≥n BLE - solo oculta la tarjeta
        function handleContinueChange(event) {
            const value = event.target.value;
            // Verificar que tenemos al menos 1 byte antes de leer
            if (value.byteLength >= 1) {
                const continueValue = value.getUint8(0);
                if (continueValue === 1) {
                    actionRequiredCard.classList.add('hidden');
                }
            } else {
                console.error('Error: Datos de continue insuficientes, recibidos:', value.byteLength, 'bytes');
            }
        }
        
        // Funci√≥n para enviar mensaje de texto al dispositivo
        async function sendMessage(message) {
            if (!messageCharacteristic) {
                console.log('Caracter√≠stica de mensaje no disponible');
                return;
            }
            
            try {
                // Convertir string a bytes (m√°ximo 50 caracteres)
                const truncatedMessage = message.substring(0, 50);
                const encoder = new TextEncoder();
                const data = encoder.encode(truncatedMessage);
                
                await messageCharacteristic.writeValue(data);
                console.log(`üì§ Mensaje enviado: "${truncatedMessage}"`);
                
            } catch (error) {
                console.error('Error al enviar mensaje:', error);
            }
        }
        
        // Modificar para que replique exactamente lo que hace handleContinueChange
        async function sendContinueSignal() {
            if (!continueCharacteristic) return;
            
            try {
                // 1. Enviar la se√±al al dispositivo
                //const value = new Uint8Array([1]);
                //await continueCharacteristic.writeValue(value);
                
                // 2. Ocultar la tarjeta de acci√≥n requerida
                actionRequiredCard.classList.add('hidden');
                
                // 3. Reenviar el paso actual pero con actionRequired = 0
                // Solo si tenemos informaci√≥n del paso actual
                if (currentStep > 0 && window.totalSteps > 0) {
                    console.log(`üì§ Reenviando paso ${currentStep}/${window.totalSteps} con actionRequired=0`);
                    try {
                        // Reenviar el mismo paso pero con actionRequired = 0
                        await sendRecipeStep(currentStep, window.totalSteps, false, currentTempTarget);
                    } catch (error) {
                        console.error('Error al reenviar paso sin acci√≥n requerida:', error);
                    }
                }
                
                statusText.textContent = 'Acci√≥n completada';
            } catch (error) {
                console.error('Error al enviar se√±al de continuar:', error);
                statusText.textContent = 'Error: ' + error.message;
            }
        }

        async function sendRecipeStep(step, totalSteps, actionRequired, tempTarget) {
            if (!stepsCharacteristic) return;
            
            try {
                const data = new Uint8Array([
                    step, 
                    totalSteps,
                    actionRequired ? 1 : 0,
                    (tempTarget >> 8) & 0xFF,
                    tempTarget & 0xFF
                ]);
                
                await stepsCharacteristic.writeValue(data);
                
                // Guardar la informaci√≥n del paso actual para posible uso posterior
                currentStep = step;
                currentTempTarget = tempTarget;
                window.totalSteps = totalSteps;
                
                stepInfo.textContent = `Paso: ${step}/${totalSteps}`;
                // NO mostrar autom√°ticamente recipeProgressCard aqu√≠
                // recipeProgressCard.classList.remove('hidden');
                
                if (tempTarget > 0) {
                    tempSetpoint.textContent = `${tempTarget}¬∞C`;
                    setpointContainer.classList.remove('hidden');
                } else {
                    // Si temperatura es 0, ocultar el contenedor de temperatura objetivo
                    setpointContainer.classList.add('hidden');
                }
                
                if (actionRequired) {
                    actionRequiredCard.classList.remove('hidden');
                }
                
            } catch (error) {
                console.error('Error al enviar paso de receta:', error);
                statusText.textContent = 'Error: ' + error.message;
            }
        }
        
        async function sendRecipeProgress(remainingTime, totalTime) {
            if (!progressCharacteristic) return;
            
            try {
                const data = new Uint8Array([
                    (remainingTime >> 8) & 0xFF,
                    remainingTime & 0xFF,
                    (totalTime >> 8) & 0xFF,
                    totalTime & 0xFF
                ]);
                
                await progressCharacteristic.writeValue(data);
                updateTimeDisplay(remainingTime, totalTime);
                
            } catch (error) {
                console.error('Error al enviar progreso de receta:', error);
            }
        }
        
        function updateTimeDisplay(remainingTime, totalTime) {
            const minutes = Math.floor(remainingTime / 60);
            const seconds = remainingTime % 60;
            
            const timeStr = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            timeRemaining.textContent = timeStr;
            
            let progress = 0;
            if (totalTime > 0) {
                progress = Math.floor(100 * (1 - remainingTime / totalTime));
            }
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = `${progress}%`;
        }
        
        async function sendRecipeStepManual() {
            if (!stepsCharacteristic) {
                alert('Dispositivo no conectado o caracter√≠stica Steps no disponible');
                return;
            }
            
            const step = parseInt(document.getElementById('stepNumber').value);
            const totalSteps = parseInt(document.getElementById('totalStepsInput').value);
            const tempSetpoint = parseInt(document.getElementById('targetTemp').value);
            const actionReq = parseInt(document.getElementById('actionRequired').value);
            
            if (isNaN(step) || isNaN(totalSteps) || isNaN(tempSetpoint) || step < 0 || totalSteps < 0 || tempSetpoint < 0) {
                alert('Por favor, completa todos los campos con valores v√°lidos');
                return;
            }
            
            console.log(`üìã Steps BLE - Paso: ${step}/${totalSteps}, Setpoint: ${tempSetpoint}¬∞C, Acci√≥n: ${actionReq ? 'Requerida' : 'No requerida'}`);
            
            // Para modo manual, mostrar la tarjeta de progreso
            recipeProgressCard.classList.remove('hidden');
            
            await sendRecipeStep(step, totalSteps, actionReq === 1, tempSetpoint);
            statusText.textContent = `‚úÖ Steps enviado: Paso ${step}/${totalSteps}, ${tempSetpoint}¬∞C`;
        }
        
        async function sendRecipeProgressManual() {
            if (!progressCharacteristic) {
                alert('Dispositivo no conectado o caracter√≠stica Progress no disponible');
                return;
            }
            
            const totalStepTime = parseInt(document.getElementById('totalTimeInput').value);
            
            if (isNaN(totalStepTime) || totalStepTime <= 0) {
                alert('Tiempo inv√°lido. Debe ser entre 1-7200 segundos');
                return;
            }
            
            const remainingTime = totalStepTime;
            
            console.log(`‚è±Ô∏è Progress BLE - Iniciando timer: ${totalStepTime}s`);
            
            await sendRecipeProgress(remainingTime, totalStepTime);
            startAutomaticTimer(remainingTime, totalStepTime);
            
            statusText.textContent = `‚è±Ô∏è Timer iniciado: ${Math.floor(totalStepTime/60)}:${(totalStepTime%60).toString().padStart(2,'0')}`;
        }
        
        async function sendRecipeProgressWithTimer(totalTime) {
            const remainingTime = totalTime;
            await sendRecipeProgress(remainingTime, totalTime);
            startAutomaticTimer(remainingTime, totalTime);
        }
        
        async function startSteakRecipe() {
            if (!device || !device.gatt.connected) {
                alert('Dispositivo no conectado');
                return;
            }
            
            statusText.textContent = 'ü•© Iniciando Filete a la Plancha...';
            
            // Mostrar tarjeta de progreso para recetas complejas
            recipeProgressCard.classList.remove('hidden');
            
            // Deshabilitar otros botones para recetas complejas
            updateRecipeButtons('complex');
            
            await sendRecipeStep(1, 3, false, 240);
            // Pasar la temperatura objetivo como par√°metro adicional (240¬∞C)
            await sendRecipeProgressAndWait(240, async () => {
                statusText.textContent = 'ü•© Colocar filete en la sart√©n';
                await sendMessage('Colocar filete');
                await sendRecipeStep(2, 3, true, 220);
                // Pasos siguientes sin monitoreo de temperatura
                await sendRecipeProgressAndWait(300, async () => {
                    statusText.textContent = 'ü•© Voltear el filete';
                    await sendMessage('Voltear filete');
                    await sendRecipeStep(3, 3, true, 200);
                    await sendRecipeProgressAndWait(240, () => {
                        statusText.textContent = 'ü•© ¬°Filete a la Plancha completado!';
                        // Ocultar temperatura objetivo cuando la receta termina
                        setpointContainer.classList.add('hidden');
                    });
                });
            }, 240); // Pasar 240¬∞C como temperatura objetivo a monitorear
        }
        
        async function sendRecipeProgressAndWait(totalTime, nextStepCallback, targetTemperature = null) {
            const remaining = totalTime;
            console.log(`üì§ Enviando progreso y esperando: ${totalTime}s` + 
                (targetTemperature ? ` (con monitoreo de temperatura: ${targetTemperature}¬∞C)` : ''));
            await sendRecipeProgress(remaining, totalTime);
            startAutomaticTimerWithCallback(remaining, totalTime, nextStepCallback, targetTemperature);
        }
        
        async function startPastaRecipe() {
            if (!device || !device.gatt.connected) {
                alert('Dispositivo no conectado');
                return;
            }

            statusText.textContent = 'üçù Iniciando Pasta Italiana...';

            // Mostrar tarjeta de progreso para recetas complejas
            recipeProgressCard.classList.remove('hidden');
            
            // Deshabilitar otros botones para recetas complejas
            updateRecipeButtons('complex');

            await sendRecipeStep(1, 3, false, 100);
            // Pasar la temperatura objetivo como par√°metro adicional (100¬∞C)
            await sendRecipeProgressAndWait(480, async () => {
                statusText.textContent = 'üçù A√±adir pasta al agua hirviendo';
                await sendMessage('A√±adir pasta');
                await sendRecipeStep(2, 3, true, 100);
                // Pasos siguientes sin monitoreo de temperatura
                await sendRecipeProgressAndWait(600, async () => {
                    statusText.textContent = 'üçù Escurrir la pasta';
                    await sendMessage('Escurrir pasta');
                    await sendRecipeStep(3, 3, true, 0);
                    await sendRecipeProgressAndWait(60, () => {
                        statusText.textContent = 'üçù ¬°Pasta Italiana completada!';
                        // Ocultar temperatura objetivo cuando la receta termina
                        setpointContainer.classList.add('hidden');
                    });
                });
            }, 100); // Pasar 100¬∞C como temperatura objetivo a monitorear
        }
        
        async function resetRecipe() {
            if (!device || !device.gatt.connected) {
                alert('Dispositivo no conectado');
                return;
            }
            
            stopAutomaticTimer();
            
            await sendRecipeStep(0, 0, false, 0);
            await sendRecipeProgress(0, 0);
            
            recipeProgressCard.classList.add('hidden');
            actionRequiredCard.classList.add('hidden');
            setpointContainer.classList.add('hidden');
            
            // Rehabilitar todos los botones
            updateRecipeButtons(null);
            
            statusText.textContent = 'Receta reseteada';
        }
        
        function startAutomaticTimer(remainingTime, totalTime) {
            stopAutomaticTimer();
            
            currentRemainingTime = remainingTime;
            currentTotalTime = totalTime;
            isTimerActive = true;
            
            updateTimeDisplay(currentRemainingTime, currentTotalTime);
            
            timerInterval = setInterval(async () => {
                if (!isTimerActive || !device || !device.gatt.connected) {
                    stopAutomaticTimer();
                    return;
                }
                
                currentRemainingTime--;
                
                if (currentRemainingTime <= 0) {
                    currentRemainingTime = 0;
                    statusText.textContent = '¬°Tiempo del paso completado!';
                    stopAutomaticTimer();
                }
                
                updateTimeDisplay(currentRemainingTime, currentTotalTime);
                
                try {
                    await sendRecipeProgressUpdate(currentRemainingTime, currentTotalTime);
                } catch (error) {
                    console.error('Error enviando actualizaci√≥n de tiempo:', error);
                    // No detener el timer, solo registrar el error para permitir que el timer contin√∫e 
                    // y que en el siguiente intento se pueda volver a enviar la actualizaci√≥n
                    //stopAutomaticTimer();
                }
                
            }, 1000);
        }
        
        // Versi√≥n modificada para incluir comprobaci√≥n de temperatura
        function startAutomaticTimerWithCallback(remainingTime, totalTime, callback, targetTemperature = null) {
            stopAutomaticTimer();

            currentRemainingTime = remainingTime;
            currentTotalTime = totalTime;
            isTimerActive = true;

            console.log(`üöÄ Iniciando timer con callback: ${remainingTime}s de ${totalTime}s` + 
                (targetTemperature ? ` (con monitoreo de temperatura: ${targetTemperature}¬∞C)` : ''));
            updateTimeDisplay(currentRemainingTime, currentTotalTime);

            timerInterval = setInterval(async () => {
                if (!isTimerActive || !device || !device.gatt.connected) {
                    console.log('‚èπÔ∏è Timer detenido - dispositivo desconectado o timer inactivo');
                    stopAutomaticTimer();
                    return;
                }
                
                // Comprobar temperatura si tenemos un valor objetivo
                if (targetTemperature !== null) {
                    // Leer temperatura actual del elemento DOM
                    const currentTempText = currentTemp.textContent;
                    const currentTempValue = parseInt(currentTempText.replace('¬∞C', ''));
                    
                    // Verificar si hemos alcanzado la temperatura objetivo (con 2¬∞C de tolerancia)
                    if (currentTempValue >= (targetTemperature - 2)) {
                        console.log(`‚úÖ Temperatura alcanzada: ${currentTempValue}¬∞C >= ${targetTemperature}¬∞C - acelerando timer a 5s`);
                        // Acelerar el timer a 5 segundos restantes
                        currentRemainingTime = 5;
                        updateTimeDisplay(currentRemainingTime, currentTotalTime);
                        
                        try {
                            await sendRecipeProgressUpdate(currentRemainingTime, currentTotalTime);
                            statusText.textContent = '‚è© Acelerando por temperatura...';
                        } catch (error) {
                            console.error('Error al actualizar progreso:', error);
                        }
                    }
                }

                // Continuar con la l√≥gica normal del timer
                currentRemainingTime--;
                
                if (currentRemainingTime % 10 === 0 || currentRemainingTime <= 5) {
                    console.log(`‚è∞ Timer: ${currentRemainingTime}s restantes`);
                }

                if (currentRemainingTime <= 0) {
                    currentRemainingTime = 0;
                    updateTimeDisplay(0, currentTotalTime);
                    console.log('‚úÖ Timer completado - ejecutando callback');

                    try { await sendRecipeProgressUpdate(0, currentTotalTime); } catch (e) {}

                    stopAutomaticTimer();

                    if (typeof callback === 'function') {
                        setTimeout(callback, 200);
                    }
                    return;
                }

                updateTimeDisplay(currentRemainingTime, currentTotalTime);
                try {
                    await sendRecipeProgressUpdate(currentRemainingTime, currentTotalTime);
                } catch (error) {
                    console.error('Error enviando actualizaci√≥n de tiempo:', error);
                    // No detener el timer, solo registrar el error para permitir que el timer contin√∫e 
                    // y que en el siguiente intento se pueda volver a enviar la actualizaci√≥n
                    //stopAutomaticTimer();
                }
            }, 1000);
        }
        
        function stopAutomaticTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                isTimerActive = false;
                console.log('‚èπÔ∏è Timer detenido');
            }
        }
        
        async function sendRecipeProgressUpdate(remainingTime, totalTime) {
            if (!progressCharacteristic) return;
            
            try {
                const data = new Uint8Array([
                    (remainingTime >> 8) & 0xFF,
                    remainingTime & 0xFF,
                    (totalTime >> 8) & 0xFF,
                    totalTime & 0xFF
                ]);
                
                await progressCharacteristic.writeValue(data);
                
                if (remainingTime % 10 === 0 || remainingTime <= 5) {
                    console.log(`‚è±Ô∏è Tiempo actualizado: ${remainingTime}s restantes de ${totalTime}s`);
                }
                
            } catch (error) {
                console.error('Error al enviar actualizaci√≥n de tiempo:', error);
                throw error;
            }
        }
        
        async function nextStep() {
            if (!device || !device.gatt.connected) {
                alert('Dispositivo no conectado');
                return;
            }
            
            if (!isTimerActive) {
                alert('No hay timer activo para acelerar');
                return;
            }
            
            // Solo acelerar a 5 segundos si el tiempo restante es mayor a 5
            if (currentRemainingTime > 5) {
                currentRemainingTime = 5;
                updateTimeDisplay(currentRemainingTime, currentTotalTime);
                
                try {
                    await sendRecipeProgressUpdate(currentRemainingTime, currentTotalTime);
                    statusText.textContent = '‚è© Acelerando al siguiente paso... (5 segundos)';
                } catch (error) {
                    console.error('Error al acelerar paso:', error);
                    statusText.textContent = 'Error al acelerar paso: ' + error.message;
                }
            } else {
                // Si ya est√° en 5 segundos o menos, no hacer nada
                console.log('El timer ya est√° cerca del final, no se acelera');
                statusText.textContent = 'Timer ya est√° terminando...';
            }
        }
        
        window.addEventListener('load', () => {
            console.log('%c SmartCookware Web App v2.7.7 ', 'background: #4CAF50; color: white; font-weight: bold; padding: 5px;');
            console.log('Build: 20241212-011');
            console.log('Loaded at:', new Date().toLocaleDateString());
            console.log('New features: Bot√≥n CONTINUAR reenv√≠a paso sin acci√≥n requerida');
        });
        
        function updateBatteryLevel(value) {
            // Verificar que tenemos al menos 1 byte antes de leer
            if (value.byteLength >= 1) {
                const batteryLevel = value.getUint8(0);
                batteryText.textContent = `Bater√≠a: ${batteryLevel}%`;
            } else {
                console.error('Error: Datos de bater√≠a insuficientes, recibidos:', value.byteLength, 'bytes');
            }
        }
        
        function updateTemperature(value) {
            // Verificar que tenemos al menos 2 bytes antes de leer uint16
            if (value.byteLength >= 2) {
                const temp = value.getUint16(0, false);
                currentTemp.textContent = `${temp}¬∞C`;
            } else {
                console.error('Error: Datos de temperatura insuficientes, recibidos:', value.byteLength, 'bytes, se esperaban 2');
            }
        }
    </script>
</body>
</html>